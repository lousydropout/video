#!/usr/bin/env python3
import json
import sys
from openai import OpenAI

client = OpenAI()
MODEL = "gpt-4.1-mini"

# ============================================================
#          Helper: multi-line human input
# ============================================================
def read_multiline_input(prompt=""):
    print(prompt)
    print("(Type 'END' on its own line to finish your message.)")
    lines = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if line.strip() == "END":
            break
        lines.append(line)
    return "\n".join(lines).strip()


# ============================================================
#                Load Bible JSON
# ============================================================
if len(sys.argv) < 2:
    print(f"Usage: {sys.argv[0]} <bible_file.json>")
    sys.exit(1)

bible_file = sys.argv[1]

try:
    with open(bible_file, "r", encoding="utf-8") as f:
        bible_data = json.load(f)
        bible = bible_data.get("canonical_json", bible_data)
    print(f"‚úì Loaded bible from '{bible_file}'")
except Exception as e:
    print(f"Error loading bible: {e}")
    sys.exit(1)


# ============================================================
#                     Agent System Prompts
# ============================================================

# ------------------------------------------------------------
# 1) SKELETON SCENE GENERATOR
# ------------------------------------------------------------
SCENE_SKELETON_SYS = """
You are the SCENE SKELETON GENERATOR.

Your job is to create a *minimal scene breakdown* for a 30-second video
based strictly on the CANONICAL BIBLE the user provides.

You are NOT responsible for camera, lighting, or style details.
You only define:
- scene_number
- rough_duration (seconds)
- description: 40‚Äì90 words, purely visual and diegetic (what we see/hear).

Rules:
- 4 to 6 scenes.
- Sum of rough_duration MUST be exactly 30.
- Descriptions must be concrete and visually grounded, no abstract phrases
  like "the atmosphere of fear spreads" ‚Äî instead, describe faces, bodies,
  actions, lighting, environment, sound, etc.
- Obey all character, object, environment, and continuity rules from the bible.

Return ONLY JSON, no prose, no backticks. Structure:

{
  "total_duration": 30,
  "scenes": [
    {
      "scene_number": 1,
      "rough_duration": 6,
      "description": "..."
    }
  ]
}
"""

# ------------------------------------------------------------
# 2) SCENE EXPANDER (adds cinematography, lighting, etc.)
# ------------------------------------------------------------
SCENE_EXPANDER_SYS = """
You are the SCENE EXPANDER AGENT.

You receive:
- The CANONICAL BIBLE
- A SKELETON SCENE LIST (scene_number, rough_duration, description)
- Optionally the CURRENT full scenes from a previous iteration
- Optional feedback from critics and the human

Your tasks:
1. For each skeleton scene, produce a *fully specified* scene entry with:
   - scene_number
   - duration (seconds; final durations must sum exactly to 30)
   - environment (must match locations from the bible)
   - description (visually explicit, model-ready)
   - camera: { framing, movement, lens, focus }
   - lighting
   - style

2. Obey the bible exactly:
   - correct character appearance, age, ethnicity, hair, wardrobe
   - teddy bear‚Äôs normal + magical forms
   - dog‚Äôs breed, coloring, posture
   - environments, time-of-day, furniture, props
   - lighting transitions and continuity
   - continuity rules for emotional arc and imagination sequence

3. Incorporate critic feedback and human feedback:
   - Fix any issues explicitly mentioned.
   - Do not regress previously correct details.

IMPORTANT:
- Descriptions must remain concrete and visual. No vague abstractions.
- Keep description lengths reasonable (not micro, not a screenplay page).
- Return ONLY JSON, no commentary or backticks.

Output structure:

{
  "total_duration": 30,
  "scenes": [
    {
      "scene_number": 1,
      "duration": 7,
      "environment": "...",
      "description": "...",
      "description_word_count": <int>,
      "camera": {
        "framing": "...",
        "movement": "...",
        "lens": "...",
        "focus": "..."
      },
      "lighting": "...",
      "style": "..."
    }
  ]
}
"""

# ------------------------------------------------------------
# 3) SCENE FORMAT + BIBLE CONSISTENCY CRITIC (per scene)
# ------------------------------------------------------------
SCENE_FORMAT_CRITIC_SYS = """
You are the SCENE FORMAT + BIBLE CONSISTENCY CRITIC.

You review ONE scene at a time, plus the bible context.
You are given:
- bible: CANONICAL BIBLE
- scene: a fully expanded scene
- total_duration: sum of all scene durations (for context, not strict check)

Your job:
- Verify this scene is *model-ready* and *bible-accurate*.

You MUST check:

1. Required fields:
   - scene_number is present
   - duration is present and > 0
   - environment is present and matches a bible environment
   - description is non-empty
   - camera has: framing, movement, lens, focus
   - lighting is described
   - style is described

2. Bible continuity:
   - characters' appearance, clothing, ethnicity, age are correct when present
   - teddy bear matches bible (normal vs imagination form)
   - dog matches bible (breed / mix, colors, posture)
   - environments obey time-of-day and decor from bible
   - lighting and style match bible rules
   - imagination rules are respected (when bear is alive vs toy)

3. Visual specificity:
   - description talks about concrete visuals: faces, bodies, poses,
     props, environment, light, sound.
   - no vague abstractions like "a sense of dread washes over everything"
     without visual anchors.

4. Word count:
   - You are given description_word_count if present. Use that as the word count.
   - You MAY mention if it seems excessively long, but you should NOT fail solely
     because of length unless it's clearly unusable (e.g., several hundred words).

Return ONLY:

{
  "pass": true/false,
  "issues": ["..."],
  "recommended_fixes": "..."
}

If pass=false, "recommended_fixes" must contain very explicit instructions,
including which scene_number and which fields need changes.
"""

# ------------------------------------------------------------
# 4) CINEMATOGRAPHY CRITIC (whole sequence)
# ------------------------------------------------------------
CINEMATOGRAPHY_CRITIC_SYS = """
You are the CINEMATOGRAPHY CRITIC.

You get the FULL SCENE LIST (not just one scene).

Judge ONLY:
- camera clarity
- spatial continuity
- lighting logic
- emotional beats
- transitions
- shot composition
- classical visual grammar

You do NOT check bible or lore accuracy.

Return ONLY:

{
  "pass": true/false,
  "notes": ["..."],
  "recommended_fixes": "..."
}
"""


# ============================================================
#                     Utility: Call OpenAI
# ============================================================
def call_openai(messages):
    r = client.chat.completions.create(
        model=MODEL,
        messages=messages,
        temperature=0.2,
    )
    return r.choices[0].message.content


# ============================================================
#              Wrapper Functions For Each Agent
# ============================================================
def generate_skeleton_scenes(bible):
    """Generate initial skeleton scenes (descriptions + rough_duration)."""
    messages = [
        {"role": "system", "content": SCENE_SKELETON_SYS},
        {"role": "user", "content": json.dumps(bible)},
    ]
    content = call_openai(messages)
    return content


def generate_expanded_scenes(bible, skeleton, human_feedback=None, critic_feedback=None, previous_scenes=None):
    """Expand skeleton into fully specified scenes."""
    messages = [
        {"role": "system", "content": SCENE_EXPANDER_SYS},
        {
            "role": "user",
            "content": json.dumps(
                {
                    "bible": bible,
                    "skeleton_scenes": skeleton,
                    "previous_scenes": previous_scenes,
                }
            ),
        },
    ]
    if critic_feedback:
        messages.append(
            {
                "role": "user",
                "content": f"CRITIC FEEDBACK TO APPLY:\n{critic_feedback}",
            }
        )
    if human_feedback:
        messages.append(
            {
                "role": "user",
                "content": f"HUMAN FEEDBACK TO APPLY:\n{human_feedback}",
            }
        )
    content = call_openai(messages)
    return content


def scene_format_check(bible, scene, total_duration):
    """Per-scene format + bible consistency critic."""
    messages = [
        {"role": "system", "content": SCENE_FORMAT_CRITIC_SYS},
        {
            "role": "user",
            "content": json.dumps(
                {
                    "bible": bible,
                    "scene": scene,
                    "total_duration": total_duration,
                }
            ),
        },
    ]
    content = call_openai(messages)
    return content


def cinematography_check(scenes_full):
    """Whole-sequence cinematography critic."""
    messages = [
        {"role": "system", "content": CINEMATOGRAPHY_CRITIC_SYS},
        {"role": "user", "content": json.dumps(scenes_full)},
    ]
    content = call_openai(messages)
    return content


# ============================================================
#                        MAIN LOGIC
# ============================================================

print("\n====================================================")
print("       PHASE 1: SKELETON SCENE GENERATION")
print("====================================================")

# 1) Generate skeleton scenes ONCE
while True:
    skeleton_str = generate_skeleton_scenes(bible)
    try:
        skeleton = json.loads(skeleton_str)
    except Exception:
        print("‚ùå Skeleton generator returned invalid JSON. Retrying‚Ä¶")
        continue

    if "scenes" not in skeleton:
        print("‚ùå Skeleton JSON missing 'scenes'. Regenerating‚Ä¶")
        continue
    if skeleton.get("total_duration") != 30:
        print("‚ùå Skeleton total_duration != 30. Regenerating‚Ä¶")
        continue

    # quick structure sanity check
    if not all("scene_number" in s and "description" in s for s in skeleton["scenes"]):
        print("‚ùå Skeleton scenes missing required fields. Regenerating‚Ä¶")
        continue

    print("\n===== SKELETON SCENES (for reference) =====")
    print(json.dumps(skeleton, indent=2))
    break


print("\n====================================================")
print("       PHASE 1: EXPANSION + CRITICS + HUMAN LOOP")
print("====================================================")

human_notes = None
critic_feedback = None
previous_scenes = None

while True:
    print("\nüîÑ Expanding scenes with cinematography + lighting‚Ä¶")

    expanded_str = generate_expanded_scenes(
        bible,
        skeleton,
        human_feedback=human_notes,
        critic_feedback=critic_feedback,
        previous_scenes=previous_scenes,
    )

    try:
        scenes_full = json.loads(expanded_str)
    except Exception:
        print("‚ùå Scene expander returned invalid JSON. Retrying with no feedback‚Ä¶")
        human_notes = None
        critic_feedback = None
        previous_scenes = None
        continue

    if "scenes" not in scenes_full:
        print("‚ùå Expanded scenes JSON missing 'scenes'. Retrying‚Ä¶")
        human_notes = None
        critic_feedback = None
        previous_scenes = None
        continue

    scenes = scenes_full["scenes"]

    # Ensure duration sum == 30
    total_duration = sum(s.get("duration", 0) for s in scenes)
    scenes_full["total_duration"] = total_duration

    # Precompute word counts and attach them to scenes
    for s in scenes:
        desc = s.get("description", "") or ""
        word_count = len(desc.split())
        s["description_word_count"] = word_count

    # ------------------ PER-SCENE FORMAT/BIBLE CRITIC ------------------
    all_pass = True
    scene_critic_summaries = []

    for s in scenes:
        scene_num = s.get("scene_number")
        print(f"\nüîç Checking scene {scene_num} against bible + format rules‚Ä¶")

        sf_raw = scene_format_check(bible, s, total_duration)
        try:
            sf = json.loads(sf_raw)
        except Exception:
            print(f"‚ùå Scene format critic returned invalid JSON for scene {scene_num}.")
            all_pass = False
            scene_critic_summaries.append(
                f"Scene {scene_num}: critic response was invalid JSON; ask generator to simplify and fix fields."
            )
            continue

        print(f"\n===== SCENE {scene_num} FORMAT/BIBLE REPORT =====")
        print(json.dumps(sf, indent=2))

        if not sf.get("pass"):
            all_pass = False

        issues = sf.get("issues") or []
        rec = sf.get("recommended_fixes") or ""
        summary = f"Scene {scene_num} issues: {issues}\nRecommended fixes: {rec}"
        scene_critic_summaries.append(summary)

    if not all_pass:
        print("\n‚ùå One or more scenes failed format/bible checks. Regenerating with critic feedback‚Ä¶")
        critic_feedback = "\n\n".join(scene_critic_summaries)
        human_notes = None
        previous_scenes = scenes_full
        continue

    # ------------------ CINEMATOGRAPHY CRITIC (WHOLE SEQUENCE) ------------------
    print("\nüé• Running cinematography critic on full scene list‚Ä¶")
    cc_raw = cinematography_check(scenes_full)
    try:
        cinema_check = json.loads(cc_raw)
    except Exception:
        print("‚ùå Cinematography critic returned invalid JSON. Ignoring for this loop.")
        cinema_check = {"pass": False, "notes": [], "recommended_fixes": ""}

    print("\n===== CINEMATOGRAPHY CRITIC REPORT =====")
    print(json.dumps(cinema_check, indent=2))

    # ------------------ HUMAN REVIEW & DECISION ------------------
    print("\n===== FINAL EXPANDED SCENES (CURRENT ITERATION) =====")
    print(json.dumps(scenes_full, indent=2))

    choice = input("\nAccept these scenes? (y/n): ").strip().lower()

    if choice == "y":
        with open("scenes.json", "w", encoding="utf-8") as f:
            json.dump(scenes_full, f, indent=2, ensure_ascii=False)
        print("\n‚úÖ Scenes accepted. scenes.json written.")
        break

    # Otherwise, gather human feedback and loop
    human_notes = read_multiline_input("\nProvide your feedback for the next iteration:")
    fix_chunks = []

    # Include scene critic summaries (even if all passed, they may contain useful notes)
    if scene_critic_summaries:
        fix_chunks.append("SCENE CRITIC NOTES:\n" + "\n\n".join(scene_critic_summaries))

    # Include cinematography critic recommendations
    if cinema_check.get("recommended_fixes"):
        fix_chunks.append("CINEMATOGRAPHY CRITIC RECOMMENDED FIXES:\n" + cinema_check["recommended_fixes"])

    critic_feedback = "\n\n".join(fix_chunks).strip()
    previous_scenes = scenes_full

print("\nPhase 1 complete.")
