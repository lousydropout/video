#!/usr/bin/env python3
import json
import sys
from datetime import datetime
from openai import OpenAI

client = OpenAI()

# ----------------------------
# SYSTEM PROMPTS
# ----------------------------

VIDEO_BIBLE_ENGINE = """
You are the VIDEO BIBLE ENGINE.

Your job is to turn ANY user prompt into a complete, production-ready world bible
with explicit details for generative image and video models.

You MUST:
- infer missing details
- resolve ambiguities
- create fully explicit character, object, and environment details
- define geometry, materials, lighting, palettes, continuity rules
- never ask user questions
- never leave attributes vague

You output:
{
  "canonical_json": { ... },
  "readable_text": "..."
}

Canonical JSON must include:
- characters
- objects
- environments
- style
- continuity
- imagination_rules (if relevant)
"""

MISSING_ATTRIBUTE_CRITIC = """
You are the ATTRIBUTE COMPLETENESS CRITIC.

Your job is to review the canonical JSON bible and evaluate whether it contains
ALL essential attributes needed for consistent generative modeling.

ONLY evaluate attribute completeness:
- character physical traits
- clothing details
- object geometry + size + materials
- environment layout + lighting
- time-of-day
- style parameters
- continuity rules
- camera-aware details

If something is missing, output:

{
  "needs_revision": true,
  "missing_attributes": [ ... ]
}

If everything required is present, output:

{
  "needs_revision": false
}
"""

CINEMATOGRAPHY_CRITIC = """
You are the CINEMATOGRAPHY CRITIC.

Your job:
- evaluate the bible for cinematic realism
- look for lighting inconsistencies
- missing spatial anchors
- broken continuity
- unclear camera geometry
- implausible staging
- inconsistent scale
- vague lighting direction
- unclear emotional arc

You NEVER override story choices.
You ONLY critique cinematography-level clarity.

OUTPUT:

{
  "notes_for_human": [...],
  "overall": "pass" | "revise"
}
"""

# ----------------------------
# HELPERS
# ----------------------------

def llm(messages, model="gpt-4.1-mini"):
    return client.chat.completions.create(
        model=model,
        messages=messages,
        temperature=0.2
    ).choices[0].message.content

# ----------------------------
# ORCHESTRATION LOOPS
# ----------------------------

def generate_bible(user_prompt):
    response = llm([
        {"role": "system", "content": VIDEO_BIBLE_ENGINE},
        {"role": "user", "content": user_prompt}
    ])
    return json.loads(response)

def missing_attribute_pass(bible_json):
    response = llm([
        {"role": "system", "content": MISSING_ATTRIBUTE_CRITIC},
        {"role": "user", "content": json.dumps(bible_json["canonical_json"])}
    ])
    return json.loads(response)

def cinematography_pass(bible_json):
    response = llm([
        {"role": "system", "content": CINEMATOGRAPHY_CRITIC},
        {"role": "user", "content": json.dumps(bible_json["canonical_json"])}
    ])
    return json.loads(response)

# ----------------------------
# MAIN LOOP
# ----------------------------

def run_bible_orchestrator():
    if len(sys.argv) < 2:
        print("Usage: {} <text_file>".format(sys.argv[0]))
        sys.exit(1)
    
    text_file = sys.argv[1]
    try:
        with open(text_file, 'r', encoding='utf-8') as f:
            user_prompt = f.read().strip()
        print(f"✓ Read prompt from '{text_file}' ({len(user_prompt)} characters)")
    except FileNotFoundError:
        print(f"Error: File '{text_file}' not found.")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading file '{text_file}': {e}")
        sys.exit(1)

    # ---- PASS 1: initial bible ----
    print("\n[PASS 1] Generating initial world bible...")
    bible = generate_bible(user_prompt)
    print("✓ Initial bible generated")

    # ---- PASS 2: completeness critic ----
    print("\n[PASS 2] Checking for missing attributes...")
    for iteration in range(5):
        print(f"  Checking completeness (iteration {iteration + 1}/5)...")
        result = missing_attribute_pass(bible)
        if not result.get("needs_revision"):
            print("✓ All required attributes present")
            break
        fixes = result["missing_attributes"]
        print(f"  Found {len(fixes)} missing attributes, regenerating bible...")

        # auto-apply fixes by regenerating bible with feedback
        feedback = "Please add the following missing attributes:\n" + json.dumps(fixes)
        bible = generate_bible(user_prompt + "\n" + feedback)
        print("  ✓ Bible regenerated with fixes")

    # ---- PASS 3: cinematography critic (recommendations only) ----
    print("\n[PASS 3] Cinematography review phase")
    while True:
        # Display the bible being critiqued
        print("\n" + "="*60)
        print("CURRENT WORLD BIBLE")
        print("="*60)
        if bible.get("readable_text"):
            print("\nReadable Text:")
            print(bible["readable_text"])
        print("\nCanonical JSON:")
        print(json.dumps(bible.get("canonical_json", {}), indent=2))
        print("="*60)
        
        print("\nRunning cinematography critique...")
        critique = cinematography_pass(bible)
        print("✓ Critique complete")
        print("\nCINEMATOGRAPHY NOTES:")
        if critique.get("notes_for_human"):
            for note in critique["notes_for_human"]:
                print(" -", note)
        else:
            print(" - No specific notes from cinematography critic.")
        
        print(f"\nCritic assessment: {critique.get('overall', 'unknown')}")
        print("\nOptions:")
        print("  - Type 'APPROVE' or 'END' (with no other input) to accept this bible and proceed to final output")
        print("  - Type improvements/adjustments (one per line, then 'END' on its own line) to regenerate")
        
        lines = []
        approved = False
        while True:
            line = input()
            stripped = line.strip()
            if stripped.upper() == "APPROVE":
                approved = True
                print("\n✓ Human approval received. Proceeding to final output.")
                break
            if stripped == "END":
                if lines:
                    print(f"✓ Received {len(lines)} line(s) of feedback")
                else:
                    approved = True
                    print("\n✓ Human approval received (END with no input). Proceeding to final output.")
                break
            lines.append(line)
        
        # Check if human approved
        if approved:
            break
        
        # Human provided feedback, regenerate bible
        print("\nRegenerating bible with your feedback...")
        human_feedback = "\n".join(lines)
        bible = generate_bible(user_prompt + "\nHuman changes:\n" + human_feedback)
        print("✓ Bible regenerated")

    print("\n===== FINAL WORLD BIBLE =====")
    print(json.dumps(bible, indent=2))
    
    # Save to disk
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_file = f"bible_{timestamp}.json"
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(bible, f, indent=2, ensure_ascii=False)
        print(f"\n✓ Final bible saved to '{output_file}'")
    except Exception as e:
        print(f"\n⚠ Error saving bible to file: {e}")


if __name__ == "__main__":
    run_bible_orchestrator()
