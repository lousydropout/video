#!/usr/bin/env python3
import json
import sys
import os
from openai import OpenAI

client = OpenAI()
MODEL = "gpt-4.1-mini"

# ============================================================
#          Helper: multi-line human input
# ============================================================
def read_multiline_input(prompt=""):
    print(prompt)
    print("(Type 'END' on its own line to finish your message.)")
    lines = []
    while True:
        try:
            line = input()
        except EOFError:
            break
        if line.strip() == "END":
            break
        lines.append(line)
    return "\n".join(lines).strip()


# ============================================================
#          Helper: Load prompts
# ============================================================
def load_prompt(filename):
    """Load a prompt file from prompts/phase1/ directory."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    prompts_dir = os.path.join(os.path.dirname(script_dir), "prompts", "phase1")
    prompt_path = os.path.join(prompts_dir, filename)
    with open(prompt_path, "r", encoding="utf-8") as f:
        return f.read().strip()


# ============================================================
#                Load Bible JSON
# ============================================================
if len(sys.argv) < 2:
    print(f"Usage: {sys.argv[0]} <bible_file.json>")
    sys.exit(1)

bible_file = sys.argv[1]

try:
    with open(bible_file, "r", encoding="utf-8") as f:
        bible_data = json.load(f)
        bible = bible_data.get("canonical_json", bible_data)
    print(f"‚úì Loaded bible from '{bible_file}'")
except Exception as e:
    print(f"Error loading bible: {e}")
    sys.exit(1)


# ============================================================
#                     Utility: Call OpenAI
# ============================================================
def call_openai(messages):
    r = client.chat.completions.create(
        model=MODEL,
        messages=messages,
        temperature=0.2,
    )
    return r.choices[0].message.content


# ============================================================
#              Wrapper Functions For Each Agent
# ============================================================
def generate_skeleton_scenes(bible):
    """Generate initial skeleton scenes (descriptions + rough_duration)."""
    SCENE_SKELETON_SYS = load_prompt("scene_skeleton_sys.txt")
    messages = [
        {"role": "system", "content": SCENE_SKELETON_SYS},
        {"role": "user", "content": json.dumps(bible)},
    ]
    content = call_openai(messages)
    return content


def generate_expanded_scenes(bible, skeleton, human_feedback=None, critic_feedback=None, previous_scenes=None):
    """Expand skeleton into fully specified scenes."""
    SCENE_EXPANDER_SYS = load_prompt("scene_expander_sys.txt")
    messages = [
        {"role": "system", "content": SCENE_EXPANDER_SYS},
        {
            "role": "user",
            "content": json.dumps(
                {
                    "bible": bible,
                    "skeleton_scenes": skeleton,
                    "previous_scenes": previous_scenes,
                }
            ),
        },
    ]
    if critic_feedback:
        messages.append(
            {
                "role": "user",
                "content": f"CRITIC FEEDBACK TO APPLY:\n{critic_feedback}",
            }
        )
    if human_feedback:
        messages.append(
            {
                "role": "user",
                "content": f"HUMAN FEEDBACK TO APPLY:\n{human_feedback}",
            }
        )
    content = call_openai(messages)
    return content


def scene_format_check(bible, scene, total_duration):
    """Per-scene format + bible consistency critic."""
    SCENE_FORMAT_CRITIC_SYS = load_prompt("scene_format_critic_sys.txt")
    messages = [
        {"role": "system", "content": SCENE_FORMAT_CRITIC_SYS},
        {
            "role": "user",
            "content": json.dumps(
                {
                    "bible": bible,
                    "scene": scene,
                    "total_duration": total_duration,
                }
            ),
        },
    ]
    content = call_openai(messages)
    return content


def cinematography_check(scenes_full):
    """Whole-sequence cinematography critic."""
    CINEMATOGRAPHY_CRITIC_SYS = load_prompt("cinematography_critic_sys.txt")
    messages = [
        {"role": "system", "content": CINEMATOGRAPHY_CRITIC_SYS},
        {"role": "user", "content": json.dumps(scenes_full)},
    ]
    content = call_openai(messages)
    return content


# ============================================================
#                        MAIN LOGIC
# ============================================================

print("\n====================================================")
print("       PHASE 1: SKELETON SCENE GENERATION")
print("====================================================")

# 1) Generate skeleton scenes ONCE
while True:
    skeleton_str = generate_skeleton_scenes(bible)
    try:
        skeleton = json.loads(skeleton_str)
    except Exception:
        print("‚ùå Skeleton generator returned invalid JSON. Retrying‚Ä¶")
        continue

    if "scenes" not in skeleton:
        print("‚ùå Skeleton JSON missing 'scenes'. Regenerating‚Ä¶")
        continue
    if skeleton.get("total_duration") != 30:
        print("‚ùå Skeleton total_duration != 30. Regenerating‚Ä¶")
        continue

    # quick structure sanity check
    if not all("scene_number" in s and "description" in s for s in skeleton["scenes"]):
        print("‚ùå Skeleton scenes missing required fields. Regenerating‚Ä¶")
        continue

    print("\n===== SKELETON SCENES (for reference) =====")
    print(json.dumps(skeleton, indent=2))
    break


print("\n====================================================")
print("       PHASE 1: EXPANSION + CRITICS + HUMAN LOOP")
print("====================================================")

human_notes = None
critic_feedback = None
previous_scenes = None

while True:
    print("\nüîÑ Expanding scenes with cinematography + lighting‚Ä¶")

    expanded_str = generate_expanded_scenes(
        bible,
        skeleton,
        human_feedback=human_notes,
        critic_feedback=critic_feedback,
        previous_scenes=previous_scenes,
    )

    try:
        scenes_full = json.loads(expanded_str)
    except Exception:
        print("‚ùå Scene expander returned invalid JSON. Retrying with no feedback‚Ä¶")
        human_notes = None
        critic_feedback = None
        previous_scenes = None
        continue

    if "scenes" not in scenes_full:
        print("‚ùå Expanded scenes JSON missing 'scenes'. Retrying‚Ä¶")
        human_notes = None
        critic_feedback = None
        previous_scenes = None
        continue

    scenes = scenes_full["scenes"]

    # Ensure duration sum == 30
    total_duration = sum(s.get("duration", 0) for s in scenes)
    scenes_full["total_duration"] = total_duration

    # Precompute word counts and attach them to scenes
    for s in scenes:
        desc = s.get("description", "") or ""
        word_count = len(desc.split())
        s["description_word_count"] = word_count

    # ------------------ PER-SCENE FORMAT/BIBLE CRITIC ------------------
    all_pass = True
    scene_critic_summaries = []

    for s in scenes:
        scene_num = s.get("scene_number")
        print(f"\nüîç Checking scene {scene_num} against bible + format rules‚Ä¶")

        sf_raw = scene_format_check(bible, s, total_duration)
        try:
            sf = json.loads(sf_raw)
        except Exception:
            print(f"‚ùå Scene format critic returned invalid JSON for scene {scene_num}.")
            all_pass = False
            scene_critic_summaries.append(
                f"Scene {scene_num}: critic response was invalid JSON; ask generator to simplify and fix fields."
            )
            continue

        print(f"\n===== SCENE {scene_num} FORMAT/BIBLE REPORT =====")
        print(json.dumps(sf, indent=2))

        if not sf.get("pass"):
            all_pass = False

        issues = sf.get("issues") or []
        rec = sf.get("recommended_fixes") or ""
        summary = f"Scene {scene_num} issues: {issues}\nRecommended fixes: {rec}"
        scene_critic_summaries.append(summary)

    if not all_pass:
        print("\n‚ùå One or more scenes failed format/bible checks. Regenerating with critic feedback‚Ä¶")
        critic_feedback = "\n\n".join(scene_critic_summaries)
        human_notes = None
        previous_scenes = scenes_full
        continue

    # ------------------ CINEMATOGRAPHY CRITIC (WHOLE SEQUENCE) ------------------
    print("\nüé• Running cinematography critic on full scene list‚Ä¶")
    cc_raw = cinematography_check(scenes_full)
    try:
        cinema_check = json.loads(cc_raw)
    except Exception:
        print("‚ùå Cinematography critic returned invalid JSON. Ignoring for this loop.")
        cinema_check = {"pass": False, "notes": [], "recommended_fixes": ""}

    print("\n===== CINEMATOGRAPHY CRITIC REPORT =====")
    print(json.dumps(cinema_check, indent=2))

    # ------------------ HUMAN REVIEW & DECISION ------------------
    print("\n===== FINAL EXPANDED SCENES (CURRENT ITERATION) =====")
    print(json.dumps(scenes_full, indent=2))

    choice = input("\nAccept these scenes? (y/n): ").strip().lower()

    if choice == "y":
        os.makedirs("artifacts/phase1", exist_ok=True)
        with open("artifacts/phase1/scenes.json", "w", encoding="utf-8") as f:
            json.dump(scenes_full, f, indent=2, ensure_ascii=False)
        print("\n‚úÖ Scenes accepted. artifacts/phase1/scenes.json written.")
        break

    # Otherwise, gather human feedback and loop
    human_notes = read_multiline_input("\nProvide your feedback for the next iteration:")
    fix_chunks = []

    # Include scene critic summaries (even if all passed, they may contain useful notes)
    if scene_critic_summaries:
        fix_chunks.append("SCENE CRITIC NOTES:\n" + "\n\n".join(scene_critic_summaries))

    # Include cinematography critic recommendations
    if cinema_check.get("recommended_fixes"):
        fix_chunks.append("CINEMATOGRAPHY CRITIC RECOMMENDED FIXES:\n" + cinema_check["recommended_fixes"])

    critic_feedback = "\n\n".join(fix_chunks).strip()
    previous_scenes = scenes_full

print("\nPhase 1 complete.")

